## Clean architecture e DDD

**Use Cases**: Estes são modelados de acordo com as funcionalidades do sistema, são classes que presentam um *comando* ou uma *query* no modelo do CQRS. Comandos afetam o estado do sistema, enquanto queries apenas puxam informações de algum lugar e são imutáveis. Use cases são considerados application services e residem na application layer acima das entidades. Use cases pertencem a um subdomínio particular, separações do problema de domínio, e.g. numa aplicação de vendas de Vinyl, você teria subdomínios como Vendas, Negociação/Ofertas, Catálogo e Usuários. Importante ter uma separação entre os atores que cada ação possui. A application layer contém os Use Cases de um subdomínio particular, eles são responsáveis por recuperar as entidades de domínio em conjunto com informações necessárias para executar determinada lógica do negócio. Estas lógicas são agnósticas no que diz respeito a camada de infraestrutura, um fluxo simples para um Use Case seria, receber um request com os dados de entrada, converter ele para entidades de domínio, realizar alguma operação, persistir esse objeto com um repositório. Dependências externas podem ser injetadas no construtor com DI. Podem ser chamados numa camada de infraestrutura, como um controller, para executar as regras. Use Cases podem chamar outros Use Cases, mas não diretamente na camada de domínio. 

**Domain Layer**: Nesta camada que os objetos que são de interesse das regras de negócio residem, estes são isolados de qualquer camada externa e são compostos principalmente por Value Object, Entities, Aggregates e Aggregates Root. Value Objects são uma forma de evitar o excesso de tipos primitivos e criar objetos imutáveis, **consistentes** e com validação própria, e.g. em vez de apresentar um CPF por uma string ter um VO CPF que faz suas validações internas de estado. Se dois VO's possuem os mesmos valores estes são considerados iguais. 

**Infrastructure layer**: Nessa camada temos tudo que é relacionado ao meio externo, como banco de dados, jobs, integrações, mailers. Quando se trata de banco de dados um padrão adotado é o repository, que consiste numa abstração para a interação com o banco de dados, ou qualquer outra forma de armazenamento, de tal forma que seja fácil mudar sua implementação sendo de fácil troca entre diferentes fontes de armazenamento. No contexto de DDD um repositório normalmente está ligado à um Aggregate Root e suas entidades. 

**Screaming architecture**: Esse conceito consiste que nossa aplicação deve modelada e separada por contextos. Numa arquitetura em camadas, n-tier architecture, temos packages ou diretório gerais e jogamos todas classes e funções de forma distribuída entre estas unidades. Dessa forma não temos uma separação clara sobre o funcionamento e o que cada classe representa. Na screaming architecture busca-se deixar de forma clara do que o código se trata. Se uma aplicação para um e-commerce então possivelmente você vai ter um contexto para a parte de pedidos, catálogo, cliente e assim por diante, vai depender da interpretação e necessidade do seu domínio. Cada escopo tem sua própria implementação e características especifícas do domínio, fazendo essa separação facilitamos o entendimento do código pois já sabemos do que se trata sem mesmo ter que ler o código. 

**Linguagem ubíqua**: Quando tratamos de uma aplicação o mais importante são as regras de negócio. O desenvolvimento de um software consiste na tradução das regras de negócio para uma programa. A linguagem ubíqua é modelada dentro de um contexto limitado, onde os termos e conceitos do domínio de negócios são identificados e não deve haver ambiguidade. Dessa forma 
é construída uma linguagem compartilhada pela equipe, desenvolvedores, especialistas de domínio e outros participantes.

O fluxo prático seguindo certo pragmatismo de forma genérica seria:

1. O cliente envia um requisição com os dados para efetuar a ação.
2. Os dados são recebidos por um Controller que pertence a uma camada externa de infraestrutura.
3. Esses dados podem ser mapeados para um DTO e convertidos em uma entidade de domínio.
4. A entidade de domínio e demais serviços são processados em um UseCase que é de fato a funcionalidade, o UseCase se preocupa em manipular a entidade de negócio e realizar determinada operação, se necessário persistir ou efetuar alguma operação com um repositório.
5. Pode ser necessário dar algum retorno ao cliente, para tal utilizamos o Presenter que monta as informações para o usuário. O UseCase não têm conhecimento de como o Presenter se comporta.


